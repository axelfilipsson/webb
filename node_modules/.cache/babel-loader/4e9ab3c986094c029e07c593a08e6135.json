{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Vector3 } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nconst _cb = new Vector3(),\n      _ab = new Vector3();\n\nclass SimplifyModifier {\n  modify(geometry, count) {\n    geometry = geometry.clone();\n    const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n    for (const name in attributes) {\n      if (name !== 'position') geometry.deleteAttribute(name);\n    }\n\n    geometry = BufferGeometryUtils.mergeVertices(geometry); //\n    // put data of original geometry in different data structures\n    //\n\n    const vertices = [];\n    const faces = []; // add vertices\n\n    const positionAttribute = geometry.getAttribute('position');\n\n    for (let i = 0; i < positionAttribute.count; i++) {\n      const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n      const vertex = new Vertex(v);\n      vertices.push(vertex);\n    } // add faces\n\n\n    let index = geometry.getIndex();\n\n    if (index !== null) {\n      for (let i = 0; i < index.count; i += 3) {\n        const a = index.getX(i);\n        const b = index.getX(i + 1);\n        const c = index.getX(i + 2);\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n        faces.push(triangle);\n      }\n    } else {\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        const a = i;\n        const b = i + 1;\n        const c = i + 2;\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n        faces.push(triangle);\n      }\n    } // compute all edge collapse costs\n\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      computeEdgeCostAtVertex(vertices[i]);\n    }\n\n    let nextVertex;\n    let z = count;\n\n    while (z--) {\n      nextVertex = minimumCostEdge(vertices);\n\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex');\n        break;\n      }\n\n      collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n    } //\n\n\n    const simplifiedGeometry = new BufferGeometry();\n    const position = [];\n    index = []; //\n\n    for (let i = 0; i < vertices.length; i++) {\n      const vertex = vertices[i].position;\n      position.push(vertex.x, vertex.y, vertex.z); // cache final index to GREATLY speed up faces reconstruction\n\n      vertices[i].id = i;\n    } //\n\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      index.push(face.v1.id, face.v2.id, face.v3.id);\n    } //\n\n\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    simplifiedGeometry.setIndex(index);\n    return simplifiedGeometry;\n  }\n\n}\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nfunction computeEdgeCollapseCost(u, v) {\n  // if we collapse edge uv by moving u to v then how\n  // much different will the model change, i.e. the \"error\".\n  const edgelength = v.position.distanceTo(u.position);\n  let curvature = 0;\n  const sideFaces = []; // find the \"sides\" triangles that are on the edge uv\n\n  for (let i = 0, il = u.faces.length; i < il; i++) {\n    const face = u.faces[i];\n\n    if (face.hasVertex(v)) {\n      sideFaces.push(face);\n    }\n  } // use the triangle facing most away from the sides\n  // to determine our curvature term\n\n\n  for (let i = 0, il = u.faces.length; i < il; i++) {\n    let minCurvature = 1;\n    const face = u.faces[i];\n\n    for (let j = 0; j < sideFaces.length; j++) {\n      const sideFace = sideFaces[j]; // use dot product of face normals.\n\n      const dotProd = face.normal.dot(sideFace.normal);\n      minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n    }\n\n    curvature = Math.max(curvature, minCurvature);\n  } // crude approach in attempt to preserve borders\n  // though it seems not to be totally correct\n\n\n  const borders = 0;\n\n  if (sideFaces.length < 2) {\n    // we add some arbitrary cost for borders,\n    // borders += 10;\n    curvature = 1;\n  }\n\n  const amt = edgelength * curvature + borders;\n  return amt;\n}\n\nfunction computeEdgeCostAtVertex(v) {\n  // compute the edge collapse cost for all edges that start\n  // from vertex v.  Since we are only interested in reducing\n  // the object by selecting the min cost edge at each step, we\n  // only cache the cost of the least cost edge at this vertex\n  // (in member variable collapse) as well as the value of the\n  // cost (in member variable collapseCost).\n  if (v.neighbors.length === 0) {\n    // collapse if no neighbors.\n    v.collapseNeighbor = null;\n    v.collapseCost = -0.01;\n    return;\n  }\n\n  v.collapseCost = 100000;\n  v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n  for (let i = 0; i < v.neighbors.length; i++) {\n    const collapseCost = computeEdgeCollapseCost(v, v.neighbors[i]);\n\n    if (!v.collapseNeighbor) {\n      v.collapseNeighbor = v.neighbors[i];\n      v.collapseCost = collapseCost;\n      v.minCost = collapseCost;\n      v.totalCost = 0;\n      v.costCount = 0;\n    }\n\n    v.costCount++;\n    v.totalCost += collapseCost;\n\n    if (collapseCost < v.minCost) {\n      v.collapseNeighbor = v.neighbors[i];\n      v.minCost = collapseCost;\n    }\n  } // we average the cost of collapsing at this vertex\n\n\n  v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n}\n\nfunction removeVertex(v, vertices) {\n  console.assert(v.faces.length === 0);\n\n  while (v.neighbors.length) {\n    const n = v.neighbors.pop();\n    removeFromArray(n.neighbors, v);\n  }\n\n  removeFromArray(vertices, v);\n}\n\nfunction removeFace(f, faces) {\n  removeFromArray(faces, f);\n  if (f.v1) removeFromArray(f.v1.faces, f);\n  if (f.v2) removeFromArray(f.v2.faces, f);\n  if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n  const vs = [f.v1, f.v2, f.v3];\n\n  for (let i = 0; i < 3; i++) {\n    const v1 = vs[i];\n    const v2 = vs[(i + 1) % 3];\n    if (!v1 || !v2) continue;\n    v1.removeIfNonNeighbor(v2);\n    v2.removeIfNonNeighbor(v1);\n  }\n}\n\nfunction collapse(vertices, faces, u, v) {\n  // u and v are pointers to vertices of an edge\n  // Collapse the edge uv by moving vertex u onto v\n  if (!v) {\n    // u is a vertex all by itself so just delete it..\n    removeVertex(u, vertices);\n    return;\n  }\n\n  const tmpVertices = [];\n\n  for (let i = 0; i < u.neighbors.length; i++) {\n    tmpVertices.push(u.neighbors[i]);\n  } // delete triangles on edge uv:\n\n\n  for (let i = u.faces.length - 1; i >= 0; i--) {\n    if (u.faces[i].hasVertex(v)) {\n      removeFace(u.faces[i], faces);\n    }\n  } // update remaining triangles to have v instead of u\n\n\n  for (let i = u.faces.length - 1; i >= 0; i--) {\n    u.faces[i].replaceVertex(u, v);\n  }\n\n  removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n  for (let i = 0; i < tmpVertices.length; i++) {\n    computeEdgeCostAtVertex(tmpVertices[i]);\n  }\n}\n\nfunction minimumCostEdge(vertices) {\n  // O(n * n) approach. TODO optimize this\n  let least = vertices[0];\n\n  for (let i = 0; i < vertices.length; i++) {\n    if (vertices[i].collapseCost < least.collapseCost) {\n      least = vertices[i];\n    }\n  }\n\n  return least;\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.normal = new Vector3();\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n\n    _cb.subVectors(vC, vB);\n\n    _ab.subVectors(vA, vB);\n\n    _cb.cross(_ab).normalize();\n\n    this.normal.copy(_cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n\nclass Vertex {\n  constructor(v) {\n    this.position = v;\n    this.id = -1; // external use position in vertices list (for e.g. face generation)\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n}\n\nexport { SimplifyModifier };","map":{"version":3,"sources":["/Users/axel/programmering/axel-filipsson-website/node_modules/three/examples/jsm/modifiers/SimplifyModifier.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","BufferGeometryUtils","_cb","_ab","SimplifyModifier","modify","geometry","count","clone","attributes","name","deleteAttribute","mergeVertices","vertices","faces","positionAttribute","getAttribute","i","v","fromBufferAttribute","vertex","Vertex","push","index","getIndex","a","getX","b","c","triangle","Triangle","il","length","computeEdgeCostAtVertex","nextVertex","z","minimumCostEdge","console","log","collapse","collapseNeighbor","simplifiedGeometry","position","x","y","id","face","v1","v2","v3","setAttribute","setIndex","pushIfUnique","array","object","indexOf","removeFromArray","k","splice","computeEdgeCollapseCost","u","edgelength","distanceTo","curvature","sideFaces","hasVertex","minCurvature","j","sideFace","dotProd","normal","dot","Math","min","max","borders","amt","neighbors","collapseCost","minCost","totalCost","costCount","removeVertex","assert","n","pop","removeFace","f","vs","removeIfNonNeighbor","tmpVertices","replaceVertex","least","constructor","computeNormal","addUniqueNeighbor","vA","vB","vC","subVectors","cross","normalize","copy","oldv","newv","offset"],"mappings":"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","sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tVector3\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nconst _cb = new Vector3(), _ab = new Vector3();\n\nclass SimplifyModifier {\n\n\tmodify( geometry, count ) {\n\n\t\tgeometry = geometry.clone();\n\t\tconst attributes = geometry.attributes;\n\n\t\t// this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tif ( name !== 'position' ) geometry.deleteAttribute( name );\n\n\t\t}\n\n\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\tconst vertices = [];\n\t\tconst faces = [];\n\n\t\t// add vertices\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tconst v = new Vector3().fromBufferAttribute( positionAttribute, i );\n\n\t\t\tconst vertex = new Vertex( v );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tlet index = geometry.getIndex();\n\n\t\tif ( index !== null ) {\n\n\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\tconst a = i;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tlet nextVertex;\n\n\t\tlet z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tconst simplifiedGeometry = new BufferGeometry();\n\t\tconst position = [];\n\n\t\tindex = [];\n\n\t\t//\n\n\t\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ].position;\n\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\t\t\t// cache final index to GREATLY speed up faces reconstruction\n\t\t\tvertices[ i ].id = i;\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tindex.push( face.v1.id, face.v2.id, face.v3.id );\n\n\t\t}\n\n\t\t//\n\n\t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t}\n\n}\n\nfunction pushIfUnique( array, object ) {\n\n\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n}\n\nfunction removeFromArray( array, object ) {\n\n\tconst k = array.indexOf( object );\n\tif ( k > - 1 ) array.splice( k, 1 );\n\n}\n\nfunction computeEdgeCollapseCost( u, v ) {\n\n\t// if we collapse edge uv by moving u to v then how\n\t// much different will the model change, i.e. the \"error\".\n\n\tconst edgelength = v.position.distanceTo( u.position );\n\tlet curvature = 0;\n\n\tconst sideFaces = [];\n\n\t// find the \"sides\" triangles that are on the edge uv\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tconst face = u.faces[ i ];\n\n\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\tsideFaces.push( face );\n\n\t\t}\n\n\t}\n\n\t// use the triangle facing most away from the sides\n\t// to determine our curvature term\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tlet minCurvature = 1;\n\t\tconst face = u.faces[ i ];\n\n\t\tfor ( let j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\tconst sideFace = sideFaces[ j ];\n\t\t\t// use dot product of face normals.\n\t\t\tconst dotProd = face.normal.dot( sideFace.normal );\n\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t}\n\n\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t}\n\n\t// crude approach in attempt to preserve borders\n\t// though it seems not to be totally correct\n\tconst borders = 0;\n\n\tif ( sideFaces.length < 2 ) {\n\n\t\t// we add some arbitrary cost for borders,\n\t\t// borders += 10;\n\t\tcurvature = 1;\n\n\t}\n\n\tconst amt = edgelength * curvature + borders;\n\n\treturn amt;\n\n}\n\nfunction computeEdgeCostAtVertex( v ) {\n\n\t// compute the edge collapse cost for all edges that start\n\t// from vertex v.  Since we are only interested in reducing\n\t// the object by selecting the min cost edge at each step, we\n\t// only cache the cost of the least cost edge at this vertex\n\t// (in member variable collapse) as well as the value of the\n\t// cost (in member variable collapseCost).\n\n\tif ( v.neighbors.length === 0 ) {\n\n\t\t// collapse if no neighbors.\n\t\tv.collapseNeighbor = null;\n\t\tv.collapseCost = - 0.01;\n\n\t\treturn;\n\n\t}\n\n\tv.collapseCost = 100000;\n\tv.collapseNeighbor = null;\n\n\t// search all neighboring edges for \"least cost\" edge\n\tfor ( let i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\tconst collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.collapseCost = collapseCost;\n\t\t\tv.minCost = collapseCost;\n\t\t\tv.totalCost = 0;\n\t\t\tv.costCount = 0;\n\n\t\t}\n\n\t\tv.costCount ++;\n\t\tv.totalCost += collapseCost;\n\n\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.minCost = collapseCost;\n\n\t\t}\n\n\t}\n\n\t// we average the cost of collapsing at this vertex\n\tv.collapseCost = v.totalCost / v.costCount;\n\t// v.collapseCost = v.minCost;\n\n}\n\nfunction removeVertex( v, vertices ) {\n\n\tconsole.assert( v.faces.length === 0 );\n\n\twhile ( v.neighbors.length ) {\n\n\t\tconst n = v.neighbors.pop();\n\t\tremoveFromArray( n.neighbors, v );\n\n\t}\n\n\tremoveFromArray( vertices, v );\n\n}\n\nfunction removeFace( f, faces ) {\n\n\tremoveFromArray( faces, f );\n\n\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t// TODO optimize this!\n\tconst vs = [ f.v1, f.v2, f.v3 ];\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst v1 = vs[ i ];\n\t\tconst v2 = vs[ ( i + 1 ) % 3 ];\n\n\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\tv1.removeIfNonNeighbor( v2 );\n\t\tv2.removeIfNonNeighbor( v1 );\n\n\t}\n\n}\n\nfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t// Collapse the edge uv by moving vertex u onto v\n\n\tif ( ! v ) {\n\n\t\t// u is a vertex all by itself so just delete it..\n\t\tremoveVertex( u, vertices );\n\t\treturn;\n\n\t}\n\n\tconst tmpVertices = [];\n\n\tfor ( let i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t}\n\n\n\t// delete triangles on edge uv:\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t}\n\n\t}\n\n\t// update remaining triangles to have v instead of u\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t}\n\n\n\tremoveVertex( u, vertices );\n\n\t// recompute the edge collapse costs in neighborhood\n\tfor ( let i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t}\n\n}\n\n\n\nfunction minimumCostEdge( vertices ) {\n\n\t// O(n * n) approach. TODO optimize this\n\n\tlet least = vertices[ 0 ];\n\n\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\tleast = vertices[ i ];\n\n\t\t}\n\n\t}\n\n\treturn least;\n\n}\n\n// we use a triangle class to represent structure of face slightly differently\n\nclass Triangle {\n\n\tconstructor( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tcomputeNormal() {\n\n\t\tconst vA = this.v1.position;\n\t\tconst vB = this.v2.position;\n\t\tconst vC = this.v3.position;\n\n\t\t_cb.subVectors( vC, vB );\n\t\t_ab.subVectors( vA, vB );\n\t\t_cb.cross( _ab ).normalize();\n\n\t\tthis.normal.copy( _cb );\n\n\t}\n\n\thasVertex( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t}\n\n\treplaceVertex( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t}\n\n}\n\nclass Vertex {\n\n\tconstructor( v ) {\n\n\t\tthis.position = v;\n\n\t\tthis.id = - 1; // external use position in vertices list (for e.g. face generation)\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t}\n\n\taddUniqueNeighbor( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t}\n\n\tremoveIfNonNeighbor( n ) {\n\n\t\tconst neighbors = this.neighbors;\n\t\tconst faces = this.faces;\n\n\t\tconst offset = neighbors.indexOf( n );\n\n\t\tif ( offset === - 1 ) return;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t}\n\n}\n\nexport { SimplifyModifier };\n"]},"metadata":{},"sourceType":"module"}