{"ast":null,"code":"import { Box3, InstancedInterleavedBuffer, InterleavedBufferAttribute, Line3, MathUtils, Matrix4, Mesh, Sphere, Vector3, Vector4 } from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\n\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\n\nconst _ssOrigin3 = new Vector3();\n\nconst _mvMatrix = new Matrix4();\n\nconst _line = new Line3();\n\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\n\nconst _sphere = new Sphere();\n\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n\n  _ssOrigin.w = 1;\n\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n  _ssOrigin.applyMatrix4(projectionMatrix);\n\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n\n  _ssOrigin3.copy(_ssOrigin);\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n\n    _end4.fromBufferAttribute(instanceEnd, i);\n\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n\n      _end4.lerp(_start4, t);\n    } // clip space\n\n\n    _start4.applyMatrix4(projectionMatrix);\n\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n    _start4.multiplyScalar(1 / _start4.w);\n\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n\n    _line.start.z = 0;\n\n    _line.end.copy(_end4);\n\n    _line.end.z = 0; // get closest point on ray to segment\n\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n\n      _line.end.fromBufferAttribute(instanceEnd, i);\n\n      _line.start.applyMatrix4(matrixWorld);\n\n      _line.end.applyMatrix4(matrixWorld);\n\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = 'LineSegments2';\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    _instanceStart = geometry.attributes.instanceStart;\n    _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n\n    let sphereMargin;\n\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n\n    _sphere.radius += sphereMargin;\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    } // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n\n    let boxMargin;\n\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n\n    _box.expandByScalar(boxMargin);\n\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n\n}\n\nexport { LineSegments2 };","map":{"version":3,"sources":["/Users/axel/programmering/axel-filipsson-website/node_modules/three/examples/jsm/lines/LineSegments2.js"],"names":["Box3","InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Sphere","Vector3","Vector4","LineSegmentsGeometry","LineMaterial","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_ray","_instanceStart","_instanceEnd","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","i","l","count","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","origin","object","face","faceIndex","uv","uv2","raycastScreenSpace","material","matrixWorld","geometry","instanceStart","attributes","instanceEnd","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","LineSegments2","constructor","color","random","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","raycast","raycaster","worldUnits","console","error","threshold","params","Line2","undefined","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox"],"mappings":"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","sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tfor ( let i = 0, l = _instanceStart.count; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( _instanceStart, i );\n\t\t_line.end.fromBufferAttribute( _instanceEnd, i );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv2: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv2: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t_instanceStart = geometry.attributes.instanceStart;\n\t\t_instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n"]},"metadata":{},"sourceType":"module"}