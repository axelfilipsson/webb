{"ast":null,"code":"import { Curve, Vector3, Vector4 } from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n  constructor(degree, knots\n  /* array of reals */\n  , controlPoints\n  /* array of Vector(2|3|4) */\n  , startKnot\n  /* index in knots */\n  , endKnot\n  /* index in knots */\n  ) {\n    super();\n    this.degree = degree;\n    this.knots = knots;\n    this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\n\n    this.startKnot = startKnot || 0;\n    this.endKnot = endKnot || this.knots.length - 1;\n\n    for (let i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      const point = controlPoints[i];\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n    // following results in (wx, wy, wz, w) homogeneous point\n\n    const hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n\n    if (hpoint.w !== 1.0) {\n      // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n      hpoint.divideScalar(hpoint.w);\n    }\n\n    return point.set(hpoint.x, hpoint.y, hpoint.z);\n  }\n\n  getTangent(t, optionalTarget = new Vector3()) {\n    const tangent = optionalTarget;\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n    const ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n    tangent.copy(ders[1]).normalize();\n    return tangent;\n  }\n\n}\n\nexport { NURBSCurve };","map":{"version":3,"sources":["/Users/axel/programmering/axel-filipsson-website/node_modules/three/examples/jsm/curves/NURBSCurve.js"],"names":["Curve","Vector3","Vector4","NURBSUtils","NURBSCurve","constructor","degree","knots","controlPoints","startKnot","endKnot","length","i","point","x","y","z","w","getPoint","t","optionalTarget","u","hpoint","calcBSplinePoint","divideScalar","set","getTangent","tangent","ders","calcNURBSDerivatives","copy","normalize"],"mappings":"AAAA,SACCA,KADD,EAECC,OAFD,EAGCC,OAHD,QAIO,OAJP;AAKA,OAAO,KAAKC,UAAZ,MAA4B,yBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,UAAN,SAAyBJ,KAAzB,CAA+B;AAE9BK,EAAAA,WAAW,CACVC,MADU,EAEVC;AAAM;AAFI,IAGVC;AAAc;AAHJ,IAIVC;AAAU;AAJA,IAKVC;AAAQ;AALE,IAMT;AAED;AAEA,SAAKJ,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,aAAL,GAAqB,EAArB,CANC,CAOD;;AACA,SAAKC,SAAL,GAAiBA,SAAS,IAAI,CAA9B;AACA,SAAKC,OAAL,GAAeA,OAAO,IAAM,KAAKH,KAAL,CAAWI,MAAX,GAAoB,CAAhD;;AAEA,SAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,aAAa,CAACG,MAAnC,EAA2C,EAAGC,CAA9C,EAAkD;AAEjD;AACA,YAAMC,KAAK,GAAGL,aAAa,CAAEI,CAAF,CAA3B;AACA,WAAKJ,aAAL,CAAoBI,CAApB,IAA0B,IAAIV,OAAJ,CAAaW,KAAK,CAACC,CAAnB,EAAsBD,KAAK,CAACE,CAA5B,EAA+BF,KAAK,CAACG,CAArC,EAAwCH,KAAK,CAACI,CAA9C,CAA1B;AAEA;AAED;;AAEDC,EAAAA,QAAQ,CAAEC,CAAF,EAAKC,cAAc,GAAG,IAAInB,OAAJ,EAAtB,EAAsC;AAE7C,UAAMY,KAAK,GAAGO,cAAd;AAEA,UAAMC,CAAC,GAAG,KAAKd,KAAL,CAAY,KAAKE,SAAjB,IAA+BU,CAAC,IAAK,KAAKZ,KAAL,CAAY,KAAKG,OAAjB,IAA6B,KAAKH,KAAL,CAAY,KAAKE,SAAjB,CAAlC,CAA1C,CAJ6C,CAI+D;AAE5G;;AACA,UAAMa,MAAM,GAAGnB,UAAU,CAACoB,gBAAX,CAA6B,KAAKjB,MAAlC,EAA0C,KAAKC,KAA/C,EAAsD,KAAKC,aAA3D,EAA0Ea,CAA1E,CAAf;;AAEA,QAAKC,MAAM,CAACL,CAAP,KAAa,GAAlB,EAAwB;AAEvB;AACAK,MAAAA,MAAM,CAACE,YAAP,CAAqBF,MAAM,CAACL,CAA5B;AAEA;;AAED,WAAOJ,KAAK,CAACY,GAAN,CAAWH,MAAM,CAACR,CAAlB,EAAqBQ,MAAM,CAACP,CAA5B,EAA+BO,MAAM,CAACN,CAAtC,CAAP;AAEA;;AAEDU,EAAAA,UAAU,CAAEP,CAAF,EAAKC,cAAc,GAAG,IAAInB,OAAJ,EAAtB,EAAsC;AAE/C,UAAM0B,OAAO,GAAGP,cAAhB;AAEA,UAAMC,CAAC,GAAG,KAAKd,KAAL,CAAY,CAAZ,IAAkBY,CAAC,IAAK,KAAKZ,KAAL,CAAY,KAAKA,KAAL,CAAWI,MAAX,GAAoB,CAAhC,IAAsC,KAAKJ,KAAL,CAAY,CAAZ,CAA3C,CAA7B;AACA,UAAMqB,IAAI,GAAGzB,UAAU,CAAC0B,oBAAX,CAAiC,KAAKvB,MAAtC,EAA8C,KAAKC,KAAnD,EAA0D,KAAKC,aAA/D,EAA8Ea,CAA9E,EAAiF,CAAjF,CAAb;AACAM,IAAAA,OAAO,CAACG,IAAR,CAAcF,IAAI,CAAE,CAAF,CAAlB,EAA0BG,SAA1B;AAEA,WAAOJ,OAAP;AAEA;;AA3D6B;;AA+D/B,SAASvB,UAAT","sourcesContent":["import {\n\tCurve,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n\n\tconstructor(\n\t\tdegree,\n\t\tknots /* array of reals */,\n\t\tcontrolPoints /* array of Vector(2|3|4) */,\n\t\tstartKnot /* index in knots */,\n\t\tendKnot /* index in knots */\n\t) {\n\n\t\tsuper();\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\n\t\tfor ( let i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tconst point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tconst hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w !== 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\tconst tangent = optionalTarget;\n\n\t\tconst u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tconst ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\ttangent.copy( ders[ 1 ] ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n}\n\nexport { NURBSCurve };\n"]},"metadata":{},"sourceType":"module"}