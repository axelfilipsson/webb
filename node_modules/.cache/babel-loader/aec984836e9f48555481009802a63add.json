{"ast":null,"code":"import { Color, Matrix4, Mesh, PerspectiveCamera, Plane, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget } from 'three';\n\nclass Reflector extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflector = true;\n    this.type = 'Reflector';\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader;\n    const multisample = options.multisample !== undefined ? options.multisample : 4; //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample\n    });\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nReflector.ReflectorShader = {\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n};\nexport { Reflector };","map":{"version":3,"sources":["/Users/axel/programmering/axel-filipsson-website/node_modules/three/examples/jsm/objects/Reflector.js"],"names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","Reflector","constructor","geometry","options","isReflector","type","camera","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose"],"mappings":"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","sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isReflector = true;\n\n\t\tthis.type = 'Reflector';\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = this.camera;\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample } );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <encodings_fragment>\n\n\t\t}`\n};\n\nexport { Reflector };\n"]},"metadata":{},"sourceType":"module"}